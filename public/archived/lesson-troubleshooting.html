<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Troubleshooting and Error Handling - Code with Morais</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .lesson-header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .lesson-header h1 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 2.5em;
        }

        .lesson-header p {
            color: #666;
            font-size: 1.2em;
        }

        .section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #3498db;
        }

        .section h3 {
            color: #34495e;
            margin: 20px 0 15px 0;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            position: relative;
        }

        .code-block::before {
            content: "Python";
            position: absolute;
            top: 5px;
            right: 10px;
            color: #95a5a6;
            font-size: 0.8em;
        }

        .error-example {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }

        .success-example {
            background: #27ae60;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }

        .info-box {
            background: #3498db;
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .warning-box {
            background: #f39c12;
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .activity-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .activity-card h3 {
            color: white;
            margin-bottom: 15px;
        }

        .btn {
            background: #3498db;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #e74c3c;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #27ae60;
        }

        .btn-success:hover {
            background: #229954;
        }

        .navigation {
            text-align: center;
            margin: 30px 0;
        }

        .error-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .error-type-card {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #e74c3c;
        }

        .testing-framework {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
        }

        .interactive-exercise {
            background: #f1c40f;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="lesson-header">
            <h1>üêõ Troubleshooting and Error Handling</h1>
            <p>Master the art of debugging, exception handling, and unit testing in Python</p>
            <div class="progress-bar">
                <div class="progress-fill" id="lessonProgress"></div>
            </div>
        </div>

        <!-- Section 5.1: Analyze, Detect, and Fix Code Segments with Errors -->
        <div class="section">
            <h2>5.1 Analyze, Detect, and Fix Code Segments</h2>
            
            <div class="info-box">
                <h3>üéØ Learning Objectives</h3>
                <ul>
                    <li>Identify different types of errors in Python code</li>
                    <li>Understand the difference between syntax, logic, and runtime errors</li>
                    <li>Develop systematic approaches to debugging</li>
                    <li>Use Python's built-in debugging tools effectively</li>
                </ul>
            </div>

            <h3>Types of Errors</h3>
            
            <div class="error-types">
                <div class="error-type-card">
                    <h4>üî¥ Syntax Errors</h4>
                    <p>Occur when Python cannot parse your code due to incorrect syntax.</p>
                    <div class="error-example">
# Syntax Error Example
print("Hello World"  # Missing closing parenthesis
# SyntaxError: unexpected EOF while parsing
                    </div>
                    <div class="success-example">
# Fixed Version
print("Hello World")  # Proper closing parenthesis
                    </div>
                </div>

                <div class="error-type-card">
                    <h4>üü† Runtime Errors (Exceptions)</h4>
                    <p>Occur during program execution when something goes wrong.</p>
                    <div class="error-example">
# Runtime Error Example
numbers = [1, 2, 3]
print(numbers[5])  # IndexError: list index out of range
                    </div>
                    <div class="success-example">
# Fixed Version
numbers = [1, 2, 3]
if len(numbers) > 5:
    print(numbers[5])
else:
    print("Index out of range")
                    </div>
                </div>

                <div class="error-type-card">
                    <h4>üü° Logic Errors</h4>
                    <p>Code runs without crashing but produces incorrect results.</p>
                    <div class="error-example">
# Logic Error Example
def calculate_average(numbers):
    return sum(numbers) / len(numbers) + 1  # Wrong formula!

# Returns incorrect average
                    </div>
                    <div class="success-example">
# Fixed Version
def calculate_average(numbers):
    return sum(numbers) / len(numbers)  # Correct formula
                    </div>
                </div>
            </div>

            <h3>Common Python Errors and Solutions</h3>
            
            <div class="code-block">
# 1. NameError - Variable not defined
try:
    print(undefined_variable)
except NameError as e:
    print(f"NameError caught: {e}")

# 2. TypeError - Wrong data type
try:
    result = "5" + 3
except TypeError as e:
    print(f"TypeError caught: {e}")
    result = int("5") + 3  # Fix: Convert string to int

# 3. ValueError - Correct type, wrong value
try:
    number = int("not_a_number")
except ValueError as e:
    print(f"ValueError caught: {e}")

# 4. KeyError - Dictionary key doesn't exist
my_dict = {"name": "John", "age": 30}
try:
    print(my_dict["height"])
except KeyError as e:
    print(f"KeyError caught: {e}")
    print(my_dict.get("height", "Height not available"))  # Safe access

# 5. IndexError - List index out of range
my_list = [1, 2, 3]
try:
    print(my_list[5])
except IndexError as e:
    print(f"IndexError caught: {e}")
            </div>

            <div class="activity-card">
                <h3>üéÆ Interactive Activity: Error Detective</h3>
                <p>Practice identifying and fixing different types of errors!</p>
                <a href="error-detective-activity.html" class="btn">Start Error Detective</a>
                <a href="debug-challenge.html" class="btn btn-danger">Debug Challenge</a>
            </div>
        </div>

        <!-- Section 5.2: Exception Handling -->
        <div class="section">
            <h2>5.2 Exception Handling with try, except, else, finally, raise</h2>
            
            <div class="info-box">
                <h3>üéØ Learning Objectives</h3>
                <ul>
                    <li>Master the try-except-else-finally structure</li>
                    <li>Learn when and how to raise custom exceptions</li>
                    <li>Handle multiple exceptions efficiently</li>
                    <li>Create robust, error-resistant programs</li>
                </ul>
            </div>

            <h3>The Complete Exception Handling Structure</h3>
            
            <div class="code-block">
def safe_division(a, b):
    """
    Demonstrates complete exception handling structure
    """
    try:
        # Code that might raise an exception
        print(f"Attempting to divide {a} by {b}")
        result = a / b
        
    except ZeroDivisionError:
        # Handle specific exception
        print("Error: Cannot divide by zero!")
        return None
        
    except TypeError:
        # Handle another specific exception
        print("Error: Invalid data types for division!")
        return None
        
    except Exception as e:
        # Handle any other exception
        print(f"Unexpected error occurred: {e}")
        return None
        
    else:
        # Executes only if no exception occurred
        print("Division completed successfully!")
        return result
        
    finally:
        # Always executes, regardless of exceptions
        print("Cleanup operations completed.")

# Examples
print("=== Example 1: Normal operation ===")
result1 = safe_division(10, 2)
print(f"Result: {result1}\n")

print("=== Example 2: Zero division ===")
result2 = safe_division(10, 0)
print(f"Result: {result2}\n")

print("=== Example 3: Type error ===")
result3 = safe_division("10", 2)
print(f"Result: {result3}\n")
            </div>

            <h3>Raising Custom Exceptions</h3>
            
            <div class="code-block">
class CustomError(Exception):
    """Custom exception class"""
    pass

class ValidationError(Exception):
    """Raised when validation fails"""
    def __init__(self, message, error_code=None):
        super().__init__(message)
        self.error_code = error_code

def validate_age(age):
    """Validates age input with custom exceptions"""
    try:
        age = int(age)
    except (ValueError, TypeError):
        raise ValidationError("Age must be a valid number", "INVALID_TYPE")
    
    if age < 0:
        raise ValidationError("Age cannot be negative", "NEGATIVE_AGE")
    
    if age > 150:
        raise ValidationError("Age seems unrealistic", "UNREALISTIC_AGE")
    
    return age

# Using custom exceptions
test_ages = [25, -5, "not_a_number", 200, "30"]

for test_age in test_ages:
    try:
        valid_age = validate_age(test_age)
        print(f"‚úì Valid age: {valid_age}")
    except ValidationError as e:
        print(f"‚úó Validation failed: {e} (Code: {e.error_code})")
            </div>

            <h3>Advanced Exception Handling Patterns</h3>
            
            <div class="code-block">
import logging

# Setup logging for better error tracking
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class FileProcessor:
    """Demonstrates advanced exception handling patterns"""
    
    def process_file(self, filename):
        """Process a file with comprehensive error handling"""
        file_handle = None
        
        try:
            # Attempt to open and process file
            logger.info(f"Opening file: {filename}")
            file_handle = open(filename, 'r')
            
            data = file_handle.read()
            
            # Simulate processing
            if not data.strip():
                raise ValueError("File is empty")
            
            processed_data = data.upper()
            return processed_data
            
        except FileNotFoundError:
            logger.error(f"File not found: {filename}")
            raise  # Re-raise the exception
            
        except PermissionError:
            logger.error(f"Permission denied: {filename}")
            return None
            
        except ValueError as e:
            logger.warning(f"Processing warning: {e}")
            return ""
            
        except Exception as e:
            logger.error(f"Unexpected error processing {filename}: {e}")
            raise  # Re-raise unexpected exceptions
            
        finally:
            # Cleanup: always close the file if it was opened
            if file_handle:
                file_handle.close()
                logger.info("File closed successfully")

# Context manager for automatic cleanup
class ManagedResource:
    def __init__(self, resource_name):
        self.resource_name = resource_name
        
    def __enter__(self):
        print(f"Acquiring resource: {self.resource_name}")
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"Releasing resource: {self.resource_name}")
        if exc_type:
            print(f"Exception occurred: {exc_type.__name__}: {exc_val}")
        return False  # Don't suppress exceptions

# Using context manager
try:
    with ManagedResource("database_connection") as resource:
        print("Working with resource...")
        # Simulate an error
        raise RuntimeError("Something went wrong!")
except RuntimeError as e:
    print(f"Handled error: {e}")
            </div>

            <div class="activity-card">
                <h3>üõ†Ô∏è Hands-On: Exception Handling Workshop</h3>
                <p>Build robust applications with proper exception handling!</p>
                <a href="exception-workshop.html" class="btn">Exception Workshop</a>
                <a href="file-processor-challenge.html" class="btn btn-success">File Processor Challenge</a>
            </div>
        </div>

        <!-- Section 5.3: Unit Testing -->
        <div class="section">
            <h2>5.3 Unit Testing with unittest Framework</h2>
            
            <div class="info-box">
                <h3>üéØ Learning Objectives</h3>
                <ul>
                    <li>Understand the importance of unit testing</li>
                    <li>Write comprehensive test cases using unittest</li>
                    <li>Master various assert methods</li>
                    <li>Implement test-driven development practices</li>
                </ul>
            </div>

            <h3>Introduction to Unit Testing</h3>
            
            <div class="testing-framework">
                <h4>Why Unit Testing?</h4>
                <ul>
                    <li>üîç <strong>Early Bug Detection:</strong> Find issues before they reach production</li>
                    <li>üìã <strong>Documentation:</strong> Tests serve as living documentation</li>
                    <li>üîÑ <strong>Refactoring Safety:</strong> Make changes with confidence</li>
                    <li>üéØ <strong>Code Quality:</strong> Encourages better design and modularity</li>
                </ul>
            </div>

            <h3>Basic unittest Structure</h3>
            
            <div class="code-block">
import unittest

# Code to be tested
class Calculator:
    """Simple calculator class for demonstration"""
    
    def add(self, a, b):
        return a + b
    
    def subtract(self, a, b):
        return a - b
    
    def multiply(self, a, b):
        return a * b
    
    def divide(self, a, b):
        if b == 0:
            raise ValueError("Cannot divide by zero")
        return a / b
    
    def power(self, base, exponent):
        return base ** exponent

# Test class
class TestCalculator(unittest.TestCase):
    """Test cases for Calculator class"""
    
    def setUp(self):
        """Set up test fixtures before each test method."""
        self.calc = Calculator()
    
    def tearDown(self):
        """Clean up after each test method."""
        # Usually used for cleanup operations
        pass
    
    def test_add_positive_numbers(self):
        """Test addition with positive numbers"""
        result = self.calc.add(5, 3)
        self.assertEqual(result, 8)
    
    def test_add_negative_numbers(self):
        """Test addition with negative numbers"""
        result = self.calc.add(-5, -3)
        self.assertEqual(result, -8)
    
    def test_subtract(self):
        """Test subtraction"""
        result = self.calc.subtract(10, 4)
        self.assertEqual(result, 6)
    
    def test_multiply(self):
        """Test multiplication"""
        result = self.calc.multiply(6, 7)
        self.assertEqual(result, 42)
    
    def test_divide_normal(self):
        """Test normal division"""
        result = self.calc.divide(15, 3)
        self.assertEqual(result, 5)
    
    def test_divide_by_zero(self):
        """Test division by zero raises exception"""
        with self.assertRaises(ValueError):
            self.calc.divide(10, 0)
    
    def test_power(self):
        """Test exponentiation"""
        result = self.calc.power(2, 3)
        self.assertEqual(result, 8)

# Run tests
if __name__ == '__main__':
    unittest.main()
            </div>

            <h3>Complete Guide to Assert Methods</h3>
            
            <div class="code-block">
import unittest

class TestAssertMethods(unittest.TestCase):
    """Comprehensive demonstration of unittest assert methods"""
    
    def test_equality_assertions(self):
        """Test various equality assertions"""
        
        # assertEqual(a, b) - Check if a == b
        self.assertEqual(5 + 3, 8)
        self.assertEqual("hello", "hello")
        
        # assertNotEqual(a, b) - Check if a != b
        self.assertNotEqual(5, 3)
        
        # assertAlmostEqual(a, b) - Check if a and b are approximately equal
        self.assertAlmostEqual(0.1 + 0.2, 0.3, places=7)
    
    def test_boolean_assertions(self):
        """Test boolean assertions"""
        
        # assertTrue(x) - Check if x is True
        self.assertTrue(5 > 3)
        self.assertTrue(bool([1, 2, 3]))
        
        # assertFalse(x) - Check if x is False
        self.assertFalse(5 < 3)
        self.assertFalse(bool([]))
    
    def test_identity_assertions(self):
        """Test identity assertions"""
        
        # assertIs(a, b) - Check if a is b (same object)
        x = [1, 2, 3]
        y = x
        self.assertIs(x, y)
        
        # assertIsNot(a, b) - Check if a is not b
        z = [1, 2, 3]
        self.assertIsNot(x, z)
        
        # assertIsNone(x) - Check if x is None
        self.assertIsNone(None)
        
        # assertIsNotNone(x) - Check if x is not None
        self.assertIsNotNone("hello")
    
    def test_membership_assertions(self):
        """Test membership assertions"""
        
        # assertIn(a, b) - Check if a is in b
        self.assertIn(3, [1, 2, 3, 4])
        self.assertIn("hello", "hello world")
        
        # assertNotIn(a, b) - Check if a is not in b
        self.assertNotIn(5, [1, 2, 3, 4])
        self.assertNotIn("goodbye", "hello world")
    
    def test_type_assertions(self):
        """Test type assertions"""
        
        # assertIsInstance(obj, cls) - Check if obj is instance of cls
        self.assertIsInstance(42, int)
        self.assertIsInstance("hello", str)
        self.assertIsInstance([1, 2, 3], list)
        
        # assertNotIsInstance(obj, cls) - Check if obj is not instance of cls
        self.assertNotIsInstance(42, str)
        self.assertNotIsInstance("hello", int)
    
    def test_exception_assertions(self):
        """Test exception assertions"""
        
        # assertRaises(exception, callable, *args) - Check if exception is raised
        with self.assertRaises(ZeroDivisionError):
            result = 1 / 0
        
        with self.assertRaises(ValueError):
            int("not_a_number")
        
        with self.assertRaises(IndexError):
            my_list = [1, 2, 3]
            item = my_list[10]
    
    def test_collection_assertions(self):
        """Test collection-specific assertions"""
        
        # assertCountEqual(a, b) - Check if a and b have same elements (ignore order)
        self.assertCountEqual([1, 2, 3], [3, 1, 2])
        
        # For dictionaries and other collections
        dict1 = {"a": 1, "b": 2}
        dict2 = {"b": 2, "a": 1}
        self.assertEqual(dict1, dict2)

# Advanced testing example with mocking and complex scenarios
class BankAccount:
    """Bank account class for testing"""
    
    def __init__(self, initial_balance=0):
        if initial_balance < 0:
            raise ValueError("Initial balance cannot be negative")
        self.balance = initial_balance
        self.transactions = []
    
    def deposit(self, amount):
        if amount <= 0:
            raise ValueError("Deposit amount must be positive")
        self.balance += amount
        self.transactions.append(f"Deposit: +${amount}")
        return self.balance
    
    def withdraw(self, amount):
        if amount <= 0:
            raise ValueError("Withdrawal amount must be positive")
        if amount > self.balance:
            raise ValueError("Insufficient funds")
        self.balance -= amount
        self.transactions.append(f"Withdrawal: -${amount}")
        return self.balance
    
    def get_balance(self):
        return self.balance
    
    def get_transaction_history(self):
        return self.transactions.copy()

class TestBankAccount(unittest.TestCase):
    """Comprehensive test suite for BankAccount"""
    
    def setUp(self):
        """Create a fresh bank account for each test"""
        self.account = BankAccount(100)  # Start with $100
    
    def test_initial_balance(self):
        """Test account creation with initial balance"""
        # Test normal creation
        account = BankAccount(50)
        self.assertEqual(account.get_balance(), 50)
        
        # Test creation with zero balance
        account_zero = BankAccount()
        self.assertEqual(account_zero.get_balance(), 0)
        
        # Test creation with negative balance (should raise exception)
        with self.assertRaises(ValueError):
            BankAccount(-10)
    
    def test_deposit(self):
        """Test deposit functionality"""
        # Test normal deposit
        new_balance = self.account.deposit(50)
        self.assertEqual(new_balance, 150)
        self.assertEqual(self.account.get_balance(), 150)
        
        # Test multiple deposits
        self.account.deposit(25)
        self.account.deposit(10)
        self.assertEqual(self.account.get_balance(), 185)
        
        # Test deposit with zero amount (should raise exception)
        with self.assertRaises(ValueError):
            self.account.deposit(0)
        
        # Test deposit with negative amount (should raise exception)
        with self.assertRaises(ValueError):
            self.account.deposit(-20)
    
    def test_withdrawal(self):
        """Test withdrawal functionality"""
        # Test normal withdrawal
        new_balance = self.account.withdraw(30)
        self.assertEqual(new_balance, 70)
        self.assertEqual(self.account.get_balance(), 70)
        
        # Test withdrawal of exact balance
        self.account.withdraw(70)
        self.assertEqual(self.account.get_balance(), 0)
        
        # Test overdraft (should raise exception)
        account_empty = BankAccount(50)
        with self.assertRaises(ValueError):
            account_empty.withdraw(60)
        
        # Test withdrawal with zero amount (should raise exception)
        with self.assertRaises(ValueError):
            self.account.withdraw(0)
        
        # Test withdrawal with negative amount (should raise exception)
        with self.assertRaises(ValueError):
            self.account.withdraw(-10)
    
    def test_transaction_history(self):
        """Test transaction history tracking"""
        # Perform several transactions
        self.account.deposit(50)
        self.account.withdraw(25)
        self.account.deposit(10)
        
        history = self.account.get_transaction_history()
        
        # Check that history has correct number of transactions
        self.assertEqual(len(history), 3)
        
        # Check specific transactions
        self.assertIn("Deposit: +$50", history)
        self.assertIn("Withdrawal: -$25", history)
        self.assertIn("Deposit: +$10", history)
        
        # Verify history is in correct order
        expected_history = [
            "Deposit: +$50",
            "Withdrawal: -$25", 
            "Deposit: +$10"
        ]
        self.assertEqual(history, expected_history)
    
    def test_edge_cases(self):
        """Test edge cases and boundary conditions"""
        # Test very large amounts
        large_account = BankAccount(1000000)
        large_account.deposit(999999999)
        self.assertIsInstance(large_account.get_balance(), (int, float))
        
        # Test floating point amounts
        float_account = BankAccount(100.50)
        float_account.deposit(25.75)
        self.assertAlmostEqual(float_account.get_balance(), 126.25, places=2)

if __name__ == '__main__':
    # Run tests with verbose output
    unittest.main(verbosity=2)
            </div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Testing Best Practices</h4>
                <ul>
                    <li><strong>Test one thing at a time:</strong> Each test should focus on a single behavior</li>
                    <li><strong>Use descriptive names:</strong> Test names should clearly describe what's being tested</li>
                    <li><strong>Test both positive and negative cases:</strong> Test expected behavior and error conditions</li>
                    <li><strong>Keep tests independent:</strong> Tests should not depend on each other</li>
                    <li><strong>Use setUp and tearDown:</strong> Prepare and clean up test environments properly</li>
                </ul>
            </div>

            <div class="activity-card">
                <h3>üß™ Testing Laboratory</h3>
                <p>Practice writing comprehensive test suites for real-world scenarios!</p>
                <a href="testing-lab.html" class="btn">Testing Lab</a>
                <a href="tdd-workshop.html" class="btn btn-success">TDD Workshop</a>
            </div>
        </div>

        <!-- Troubleshooting Guide -->
        <div class="section">
            <h2>üîß Comprehensive Troubleshooting Guide</h2>
            
            <div class="info-box">
                <h3>üéØ Debugging Methodology</h3>
                <ol>
                    <li><strong>Reproduce the error:</strong> Make the error happen consistently</li>
                    <li><strong>Read error messages carefully:</strong> They often tell you exactly what's wrong</li>
                    <li><strong>Check the stack trace:</strong> Follow the execution path to the error</li>
                    <li><strong>Use print statements:</strong> Add debugging output to trace execution</li>
                    <li><strong>Use a debugger:</strong> Step through code line by line</li>
                    <li><strong>Test small parts:</strong> Isolate the problem to smallest possible section</li>
                </ol>
            </div>

            <h3>Common Error Patterns and Solutions</h3>
            
            <div class="code-block">
# 1. INDENTATION ERRORS - Very common in Python
# Wrong:
def my_function():
print("Hello")  # IndentationError

# Correct:
def my_function():
    print("Hello")  # Proper indentation

# 2. VARIABLE SCOPE ISSUES
def function_with_scope_issue():
    if True:
        x = 10
    print(x)  # NameError: name 'x' is not defined

# Fix: Declare variables in proper scope
def function_with_proper_scope():
    x = None  # Initialize before conditional
    if True:
        x = 10
    print(x)  # Works fine

# 3. MUTABLE DEFAULT ARGUMENTS - Dangerous!
def dangerous_function(items=[]):  # Don't do this!
    items.append("new_item")
    return items

# Problem: The list is shared between calls
print(dangerous_function())  # ['new_item']
print(dangerous_function())  # ['new_item', 'new_item'] - Unexpected!

# Fix: Use None as default and create new list inside function
def safe_function(items=None):
    if items is None:
        items = []
    items.append("new_item")
    return items

# 4. STRING/INTEGER CONCATENATION
# Wrong:
age = 25
message = "I am " + age + " years old"  # TypeError

# Correct:
age = 25
message = "I am " + str(age) + " years old"
# Or better:
message = f"I am {age} years old"

# 5. MODIFYING LIST WHILE ITERATING
numbers = [1, 2, 3, 4, 5]

# Wrong - can cause unexpected behavior:
for num in numbers:
    if num % 2 == 0:
        numbers.remove(num)  # Dangerous!

# Correct - iterate over a copy:
numbers = [1, 2, 3, 4, 5]
for num in numbers[:]:  # Create a copy with [:]
    if num % 2 == 0:
        numbers.remove(num)

# Or use list comprehension:
numbers = [num for num in numbers if num % 2 != 0]
            </div>

            <h3>Debugging Tools and Techniques</h3>
            
            <div class="code-block">
import pdb  # Python Debugger
import traceback
import sys

def debugging_example():
    """Demonstrates various debugging techniques"""
    
    # 1. Using print for debugging
    def debug_with_print():
        x = 10
        y = 20
        print(f"DEBUG: x={x}, y={y}")  # Debug output
        result = x + y
        print(f"DEBUG: result={result}")
        return result
    
    # 2. Using assert for debugging (removed in production with -O flag)
    def debug_with_assert():
        x = 10
        assert x > 0, f"x should be positive, got {x}"
        assert isinstance(x, int), f"x should be int, got {type(x)}"
        return x * 2
    
    # 3. Using try-except to catch and analyze errors
    def debug_with_exception_handling():
        try:
            # Some risky operation
            result = 10 / 0
        except Exception as e:
            print(f"Exception type: {type(e).__name__}")
            print(f"Exception message: {str(e)}")
            print(f"Exception args: {e.args}")
            
            # Get detailed traceback
            print("Full traceback:")
            traceback.print_exc()
            
            # Get traceback as string for logging
            tb_str = traceback.format_exc()
            print("Traceback string:", tb_str)
    
    # 4. Using pdb for interactive debugging
    def debug_with_pdb():
        x = 10
        y = 20
        pdb.set_trace()  # Debugger will pause here
        result = x + y
        return result
    
    # Example calls
    print("=== Print Debugging ===")
    debug_with_print()
    
    print("\n=== Assert Debugging ===")
    debug_with_assert()
    
    print("\n=== Exception Analysis ===")
    debug_with_exception_handling()
    
    # Uncomment to try interactive debugging:
    # print("\n=== Interactive Debugging ===")
    # debug_with_pdb()

# Advanced error analysis
def analyze_error(func, *args, **kwargs):
    """Wrapper function to analyze errors in detail"""
    try:
        result = func(*args, **kwargs)
        print(f"‚úì Function {func.__name__} executed successfully")
        return result
    except Exception as e:
        print(f"‚úó Error in {func.__name__}:")
        print(f"  Type: {type(e).__name__}")
        print(f"  Message: {str(e)}")
        print(f"  Args: {e.args}")
        
        # Get the frame where error occurred
        exc_type, exc_value, exc_traceback = sys.exc_info()
        
        print("  Stack trace:")
        for frame_info in traceback.extract_tb(exc_traceback):
            print(f"    File: {frame_info.filename}")
            print(f"    Line: {frame_info.lineno}")
            print(f"    Function: {frame_info.name}")
            print(f"    Code: {frame_info.line}")
            print()
        
        return None

# Example usage
def problematic_function(a, b):
    return a / b

# Test with error analysis
print("=== Error Analysis Demo ===")
analyze_error(problematic_function, 10, 2)   # Success
analyze_error(problematic_function, 10, 0)   # Division by zero
analyze_error(problematic_function, "10", 2) # Type error
            </div>

            <div class="interactive-exercise">
                <h4>üéØ Interactive Debugging Exercise</h4>
                <p>Try debugging this broken code step by step:</p>
                <div class="code-block">
def broken_function():
    numbers = [1, 2, 3, 4, 5]
    total = 0
    
    for i in range(len(numbers) + 1):  # Bug: index out of range
        total += numbers[i]
    
    average = total / 0  # Bug: division by zero
    
    return average

# Your task: Find and fix all bugs!
# Hint: Use the debugging techniques shown above
                </div>
            </div>
        </div>

        <!-- Summary and Next Steps -->
        <div class="section">
            <h2>üìö Chapter Summary</h2>
            
            <div class="info-box">
                <h3>üéØ What You've Learned</h3>
                <ul>
                    <li>‚úÖ <strong>Error Types:</strong> Syntax, runtime, and logic errors</li>
                    <li>‚úÖ <strong>Exception Handling:</strong> try, except, else, finally, raise</li>
                    <li>‚úÖ <strong>Unit Testing:</strong> unittest framework and assert methods</li>
                    <li>‚úÖ <strong>Debugging:</strong> Systematic troubleshooting approaches</li>
                    <li>‚úÖ <strong>Best Practices:</strong> Writing robust, testable code</li>
                </ul>
            </div>

            <div class="warning-box">
                <h4>üîë Key Takeaways</h4>
                <ul>
                    <li><strong>Expect Errors:</strong> Always assume things can go wrong and prepare for them</li>
                    <li><strong>Test Early and Often:</strong> Write tests as you develop, not afterward</li>
                    <li><strong>Read Error Messages:</strong> They're your best friend in debugging</li>
                    <li><strong>Use the Right Tool:</strong> Different debugging techniques for different problems</li>
                    <li><strong>Document Your Tests:</strong> Good test names are documentation</li>
                </ul>
            </div>

            <h3>üöÄ Next Steps</h3>
            <div class="activity-card">
                <h3>Continue Your Journey</h3>
                <p>Ready for more advanced Python concepts?</p>
                <a href="lesson-advanced-functions.html" class="btn">Advanced Functions</a>
                <a href="lesson-object-oriented.html" class="btn">Object-Oriented Programming</a>
                <a href="practice-problems.html" class="btn btn-success">Practice Problems</a>
            </div>
        </div>

        <!-- Navigation -->
        <div class="navigation">
            <a href="lesson-control-flow.html" class="btn">‚Üê Previous: Control Flow</a>
            <a href="index.html" class="btn">üè† Home</a>
            <a href="lesson-advanced-functions.html" class="btn">Next: Advanced Functions ‚Üí</a>
        </div>
    </div>

    <script>
        // Progress tracking
        let progress = 0;
        const sections = document.querySelectorAll('.section');
        const progressFill = document.getElementById('lessonProgress');
        
        function updateProgress() {
            const scrollPosition = window.scrollY;
            const documentHeight = document.documentElement.scrollHeight - window.innerHeight;
            progress = (scrollPosition / documentHeight) * 100;
            progressFill.style.width = progress + '%';
        }
        
        window.addEventListener('scroll', updateProgress);
        
        // Interactive elements
        document.addEventListener('DOMContentLoaded', function() {
            // Add click handlers for code blocks to copy code
            document.querySelectorAll('.code-block').forEach(block => {
                block.addEventListener('click', function() {
                    navigator.clipboard.writeText(this.textContent);
                    
                    // Visual feedback
                    const originalBg = this.style.backgroundColor;
                    this.style.backgroundColor = '#27ae60';
                    setTimeout(() => {
                        this.style.backgroundColor = originalBg;
                    }, 200);
                });
            });
            
            console.log('üêõ Troubleshooting and Error Handling lesson loaded!');
            console.log('üí° Tip: Click on code blocks to copy them to clipboard');
        });
    </script>
</body>
</html>